"""
A directive used by the Apollo iOS client to annotate operations or fragments that should be used exclusively for generating local cache mutations instead of as standard operations.
"""
directive @apollo_client_ios_localCacheMutation on QUERY | MUTATION | SUBSCRIPTION | FRAGMENT_DEFINITION

"""
A directive used by the Apollo iOS code generation engine to generate custom import statements in operation or fragment definition files. An import statement to import a module with the name provided in the `module` argument will be added to the generated definition file.
"""
directive @import(
  """The name of the module to import."""
  module: String!
) repeatable on QUERY | MUTATION | SUBSCRIPTION | FRAGMENT_DEFINITION

"""Attach extra information to a given type."""
directive @typePolicy(
  """
  A selection set containing fields used to compute the cache key of an object. Referenced fields must have non-nullable scalar types. Order is important.
  """
  keyFields: String!
) on OBJECT | INTERFACE

"""
Directs the executor to defer this fragment when the `if` argument is true or undefined.
"""
directive @defer(
  """Deferred when true or undefined."""
  if: Boolean

  """Unique name"""
  label: String
) on FRAGMENT_SPREAD | INLINE_FRAGMENT

"""A high precision floating point value represented as a string"""
scalar BigFloat

"""
Boolean expression comparing fields on type "BigFloat"
"""
input BigFloatFilter {
  eq: BigFloat
  gt: BigFloat
  gte: BigFloat
  in: [BigFloat!]
  is: FilterIs
  lt: BigFloat
  lte: BigFloat
  neq: BigFloat
}

"""
Boolean expression comparing fields on type "BigFloatList"
"""
input BigFloatListFilter {
  containedBy: [BigFloat!]
  contains: [BigFloat!]
  eq: [BigFloat!]
  is: FilterIs
  overlaps: [BigFloat!]
}

"""An arbitrary size integer represented as a string"""
scalar BigInt

"""
Boolean expression comparing fields on type "BigInt"
"""
input BigIntFilter {
  eq: BigInt
  gt: BigInt
  gte: BigInt
  in: [BigInt!]
  is: FilterIs
  lt: BigInt
  lte: BigInt
  neq: BigInt
}

"""
Boolean expression comparing fields on type "BigIntList"
"""
input BigIntListFilter {
  containedBy: [BigInt!]
  contains: [BigInt!]
  eq: [BigInt!]
  is: FilterIs
  overlaps: [BigInt!]
}

"""
Boolean expression comparing fields on type "Boolean"
"""
input BooleanFilter {
  eq: Boolean
  is: FilterIs
}

"""
Boolean expression comparing fields on type "BooleanList"
"""
input BooleanListFilter {
  containedBy: [Boolean!]
  contains: [Boolean!]
  eq: [Boolean!]
  is: FilterIs
  overlaps: [Boolean!]
}

enum CatalogueType {
  op
  k
  twv
  bwv
  d
  hob
  rv
  s
  hwv
  h
  cnw
  woo
  do
  fp
  cd
  wab
  cff
  ms
  m
  bv
  b
  sz
  jb
  lwv
  eg
  th
  wwv
  wd
  wq
  jw
  trv
  mwv
}

"""
Boolean expression comparing fields on type "CatalogueType"
"""
input CatalogueTypeFilter {
  eq: CatalogueType
  in: [CatalogueType!]
  is: FilterIs
  neq: CatalogueType
}

"""
Join table linking pieces to collections with optional position ordering
"""
type CollectionPieces implements Node {
  """Globally Unique Record Identifier"""
  nodeId: ID!
  id: BigInt!
  pieceId: BigInt!
  collectionId: BigInt!
  position: Int
  piece: Piece!
  collection: Collections!
}

type CollectionPiecesConnection {
  edges: [CollectionPiecesEdge!]!
  pageInfo: PageInfo!

  """The total number of records matching the `filter` criteria"""
  totalCount: Int!
}

type CollectionPiecesDeleteResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [CollectionPieces!]!
}

type CollectionPiecesEdge {
  cursor: String!
  node: CollectionPieces!
}

input CollectionPiecesFilter {
  id: BigIntFilter
  pieceId: BigIntFilter
  collectionId: BigIntFilter
  position: IntFilter
  nodeId: IDFilter

  """
  Returns true only if all its inner filters are true, otherwise returns false
  """
  and: [CollectionPiecesFilter!]

  """
  Returns true if at least one of its inner filters is true, otherwise returns false
  """
  or: [CollectionPiecesFilter!]

  """Negates a filter"""
  not: CollectionPiecesFilter
}

input CollectionPiecesInsertInput {
  pieceId: BigInt
  collectionId: BigInt
  position: Int
}

type CollectionPiecesInsertResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [CollectionPieces!]!
}

input CollectionPiecesOrderBy {
  id: OrderByDirection
  pieceId: OrderByDirection
  collectionId: OrderByDirection
  position: OrderByDirection
}

input CollectionPiecesUpdateInput {
  pieceId: BigInt
  collectionId: BigInt
  position: Int
}

type CollectionPiecesUpdateResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [CollectionPieces!]!
}

type Collections implements Node {
  """Globally Unique Record Identifier"""
  nodeId: ID!
  id: BigInt!
  name: String!
  url: String
  composerId: BigInt
  searchableText: String
  searchable: Boolean!
  userId: UUID
  composer: Composers
  collectionPieces(
    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: CollectionPiecesFilter

    """Sort order to apply to the collection"""
    orderBy: [CollectionPiecesOrderBy!]
  ): CollectionPiecesConnection

  """
  Returns pieces belonging to this collection, prioritizing user-customized pieces over default pieces with the same IMSLP URL
  """
  pieces(
    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: PieceFilter

    """Sort order to apply to the collection"""
    orderBy: [PieceOrderBy!]
  ): PieceConnection
}

type CollectionsConnection {
  edges: [CollectionsEdge!]!
  pageInfo: PageInfo!
}

type CollectionsDeleteResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [Collections!]!
}

type CollectionsEdge {
  cursor: String!
  node: Collections!
}

input CollectionsFilter {
  id: BigIntFilter
  name: StringFilter
  url: StringFilter
  composerId: BigIntFilter
  searchableText: StringFilter
  searchable: BooleanFilter
  userId: UUIDFilter
  nodeId: IDFilter

  """
  Returns true only if all its inner filters are true, otherwise returns false
  """
  and: [CollectionsFilter!]

  """
  Returns true if at least one of its inner filters is true, otherwise returns false
  """
  or: [CollectionsFilter!]

  """Negates a filter"""
  not: CollectionsFilter
}

input CollectionsInsertInput {
  id: BigInt
  name: String
  url: String
  composerId: BigInt
  searchableText: String
  searchable: Boolean
  userId: UUID
}

type CollectionsInsertResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [Collections!]!
}

input CollectionsOrderBy {
  id: OrderByDirection
  name: OrderByDirection
  url: OrderByDirection
  composerId: OrderByDirection
  searchableText: OrderByDirection
  searchable: OrderByDirection
  userId: OrderByDirection
}

input CollectionsUpdateInput {
  id: BigInt
  name: String
  url: String
  composerId: BigInt
  searchableText: String
  searchable: Boolean
  userId: UUID
}

type CollectionsUpdateResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [Collections!]!
}

type Composers implements Node {
  """Globally Unique Record Identifier"""
  nodeId: ID!
  id: BigInt!
  firstName: String!
  lastName: String!
  nationality: String
  musicalEra: String
  userId: UUID
  searchableText: String
  searchable: Boolean!
  pieceCollection(
    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: PieceFilter

    """Sort order to apply to the collection"""
    orderBy: [PieceOrderBy!]
  ): PieceConnection
  collectionsCollection(
    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: CollectionsFilter

    """Sort order to apply to the collection"""
    orderBy: [CollectionsOrderBy!]
  ): CollectionsConnection
}

type ComposersConnection {
  edges: [ComposersEdge!]!
  pageInfo: PageInfo!
}

type ComposersDeleteResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [Composers!]!
}

type ComposersEdge {
  cursor: String!
  node: Composers!
}

input ComposersFilter {
  id: BigIntFilter
  firstName: StringFilter
  lastName: StringFilter
  nationality: StringFilter
  musicalEra: StringFilter
  userId: UUIDFilter
  searchableText: StringFilter
  searchable: BooleanFilter
  nodeId: IDFilter

  """
  Returns true only if all its inner filters are true, otherwise returns false
  """
  and: [ComposersFilter!]

  """
  Returns true if at least one of its inner filters is true, otherwise returns false
  """
  or: [ComposersFilter!]

  """Negates a filter"""
  not: ComposersFilter
}

input ComposersInsertInput {
  firstName: String
  lastName: String
  nationality: String
  musicalEra: String
  userId: UUID
  searchableText: String
  searchable: Boolean
}

type ComposersInsertResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [Composers!]!
}

input ComposersOrderBy {
  id: OrderByDirection
  firstName: OrderByDirection
  lastName: OrderByDirection
  nationality: OrderByDirection
  musicalEra: OrderByDirection
  userId: OrderByDirection
  searchableText: OrderByDirection
  searchable: OrderByDirection
}

input ComposersUpdateInput {
  firstName: String
  lastName: String
  nationality: String
  musicalEra: String
  userId: UUID
  searchableText: String
  searchable: Boolean
}

type ComposersUpdateResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [Composers!]!
}

"""
An opaque string using for tracking a position in results during pagination
"""
scalar Cursor

"""A date wihout time information"""
scalar Date

"""
Boolean expression comparing fields on type "Date"
"""
input DateFilter {
  eq: Date
  gt: Date
  gte: Date
  in: [Date!]
  is: FilterIs
  lt: Date
  lte: Date
  neq: Date
}

"""
Boolean expression comparing fields on type "DateList"
"""
input DateListFilter {
  containedBy: [Date!]
  contains: [Date!]
  eq: [Date!]
  is: FilterIs
  overlaps: [Date!]
}

"""A date and time"""
scalar Datetime

"""
Boolean expression comparing fields on type "Datetime"
"""
input DatetimeFilter {
  eq: Datetime
  gt: Datetime
  gte: Datetime
  in: [Datetime!]
  is: FilterIs
  lt: Datetime
  lte: Datetime
  neq: Datetime
}

"""
Boolean expression comparing fields on type "DatetimeList"
"""
input DatetimeListFilter {
  containedBy: [Datetime!]
  contains: [Datetime!]
  eq: [Datetime!]
  is: FilterIs
  overlaps: [Datetime!]
}

enum FilterIs {
  NULL
  NOT_NULL
}

"""
Boolean expression comparing fields on type "Float"
"""
input FloatFilter {
  eq: Float
  gt: Float
  gte: Float
  in: [Float!]
  is: FilterIs
  lt: Float
  lte: Float
  neq: Float
}

"""
Boolean expression comparing fields on type "FloatList"
"""
input FloatListFilter {
  containedBy: [Float!]
  contains: [Float!]
  eq: [Float!]
  is: FilterIs
  overlaps: [Float!]
}

"""
Boolean expression comparing fields on type "ID"
"""
input IDFilter {
  eq: ID
}

"""
Boolean expression comparing fields on type "Int"
"""
input IntFilter {
  eq: Int
  gt: Int
  gte: Int
  in: [Int!]
  is: FilterIs
  lt: Int
  lte: Int
  neq: Int
}

"""
Boolean expression comparing fields on type "IntList"
"""
input IntListFilter {
  containedBy: [Int!]
  contains: [Int!]
  eq: [Int!]
  is: FilterIs
  overlaps: [Int!]
}

"""A Javascript Object Notation value serialized as a string"""
scalar JSON

enum KeySignatureType {
  c
  csharp
  cflat
  d
  dsharp
  dflat
  e
  esharp
  eflat
  f
  fsharp
  fflat
  g
  gsharp
  gflat
  a
  asharp
  aflat
  b
  bsharp
  bflat
  cminor
  csharpminor
  cflatminor
  dminor
  dsharpminor
  dflatminor
  eminor
  esharpminor
  eflatminor
  fminor
  fsharpminor
  fflatminor
  gminor
  gsharpminor
  gflatminor
  aminor
  asharpminor
  aflatminor
  bminor
  bsharpminor
  bflatminor
}

"""
Boolean expression comparing fields on type "KeySignatureType"
"""
input KeySignatureTypeFilter {
  eq: KeySignatureType
  in: [KeySignatureType!]
  is: FilterIs
  neq: KeySignatureType
}

type Movement implements Node {
  """Globally Unique Record Identifier"""
  nodeId: ID!
  id: BigInt!
  pieceId: BigInt!
  name: String
  number: Int
  keySignature: KeySignatureType
  nickname: String
  downloadUrl: String
  totalPracticeTime: Int
  lastPracticed: Datetime
  piece: Piece!
  practiceSessionsCollection(
    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: PracticeSessionsFilter

    """Sort order to apply to the collection"""
    orderBy: [PracticeSessionsOrderBy!]
  ): PracticeSessionsConnection
}

type MovementConnection {
  edges: [MovementEdge!]!
  pageInfo: PageInfo!
}

type MovementDeleteResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [Movement!]!
}

type MovementEdge {
  cursor: String!
  node: Movement!
}

input MovementFilter {
  id: BigIntFilter
  pieceId: BigIntFilter
  name: StringFilter
  number: IntFilter
  keySignature: KeySignatureTypeFilter
  nickname: StringFilter
  downloadUrl: StringFilter
  totalPracticeTime: IntFilter
  lastPracticed: DatetimeFilter
  nodeId: IDFilter

  """
  Returns true only if all its inner filters are true, otherwise returns false
  """
  and: [MovementFilter!]

  """
  Returns true if at least one of its inner filters is true, otherwise returns false
  """
  or: [MovementFilter!]

  """Negates a filter"""
  not: MovementFilter
}

input MovementInsertInput {
  pieceId: BigInt
  name: String
  number: Int
  keySignature: KeySignatureType
  nickname: String
  downloadUrl: String
  totalPracticeTime: Int
  lastPracticed: Datetime
}

type MovementInsertResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [Movement!]!
}

input MovementOrderBy {
  id: OrderByDirection
  pieceId: OrderByDirection
  name: OrderByDirection
  number: OrderByDirection
  keySignature: OrderByDirection
  nickname: OrderByDirection
  downloadUrl: OrderByDirection
  totalPracticeTime: OrderByDirection
  lastPracticed: OrderByDirection
}

input MovementUpdateInput {
  pieceId: BigInt
  name: String
  number: Int
  keySignature: KeySignatureType
  nickname: String
  downloadUrl: String
  totalPracticeTime: Int
  lastPracticed: Datetime
}

type MovementUpdateResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [Movement!]!
}

"""The root type for creating and mutating data"""
type Mutation {
  """Deletes zero or more records from the `CollectionPieces` collection"""
  deleteFromCollectionPiecesCollection(
    """Restricts the mutation's impact to records matching the criteria"""
    filter: CollectionPiecesFilter

    """
    The maximum number of records in the collection permitted to be affected
    """
    atMost: Int! = 1
  ): CollectionPiecesDeleteResponse!

  """Deletes zero or more records from the `Collections` collection"""
  deleteFromCollectionsCollection(
    """Restricts the mutation's impact to records matching the criteria"""
    filter: CollectionsFilter

    """
    The maximum number of records in the collection permitted to be affected
    """
    atMost: Int! = 1
  ): CollectionsDeleteResponse!

  """Deletes zero or more records from the `Composers` collection"""
  deleteFromComposersCollection(
    """Restricts the mutation's impact to records matching the criteria"""
    filter: ComposersFilter

    """
    The maximum number of records in the collection permitted to be affected
    """
    atMost: Int! = 1
  ): ComposersDeleteResponse!

  """Deletes zero or more records from the `Movement` collection"""
  deleteFromMovementCollection(
    """Restricts the mutation's impact to records matching the criteria"""
    filter: MovementFilter

    """
    The maximum number of records in the collection permitted to be affected
    """
    atMost: Int! = 1
  ): MovementDeleteResponse!

  """Deletes zero or more records from the `Piece` collection"""
  deleteFromPieceCollection(
    """Restricts the mutation's impact to records matching the criteria"""
    filter: PieceFilter

    """
    The maximum number of records in the collection permitted to be affected
    """
    atMost: Int! = 1
  ): PieceDeleteResponse!

  """Deletes zero or more records from the `PracticeSessions` collection"""
  deleteFromPracticeSessionsCollection(
    """Restricts the mutation's impact to records matching the criteria"""
    filter: PracticeSessionsFilter

    """
    The maximum number of records in the collection permitted to be affected
    """
    atMost: Int! = 1
  ): PracticeSessionsDeleteResponse!
  getPieceSearchableText(pieceId: BigInt!): String

  """Adds one or more `CollectionPieces` records to the collection"""
  insertIntoCollectionPiecesCollection(objects: [CollectionPiecesInsertInput!]!): CollectionPiecesInsertResponse

  """Adds one or more `Collections` records to the collection"""
  insertIntoCollectionsCollection(objects: [CollectionsInsertInput!]!): CollectionsInsertResponse

  """Adds one or more `Composers` records to the collection"""
  insertIntoComposersCollection(objects: [ComposersInsertInput!]!): ComposersInsertResponse

  """Adds one or more `Movement` records to the collection"""
  insertIntoMovementCollection(objects: [MovementInsertInput!]!): MovementInsertResponse

  """Adds one or more `Piece` records to the collection"""
  insertIntoPieceCollection(objects: [PieceInsertInput!]!): PieceInsertResponse

  """Adds one or more `PracticeSessions` records to the collection"""
  insertIntoPracticeSessionsCollection(objects: [PracticeSessionsInsertInput!]!): PracticeSessionsInsertResponse
  refreshAllSearchableText: Opaque

  """Updates zero or more records in the `CollectionPieces` collection"""
  updateCollectionPiecesCollection(
    """
    Fields that are set will be updated for all records matching the `filter`
    """
    set: CollectionPiecesUpdateInput!

    """Restricts the mutation's impact to records matching the criteria"""
    filter: CollectionPiecesFilter

    """
    The maximum number of records in the collection permitted to be affected
    """
    atMost: Int! = 1
  ): CollectionPiecesUpdateResponse!

  """Updates zero or more records in the `Collections` collection"""
  updateCollectionsCollection(
    """
    Fields that are set will be updated for all records matching the `filter`
    """
    set: CollectionsUpdateInput!

    """Restricts the mutation's impact to records matching the criteria"""
    filter: CollectionsFilter

    """
    The maximum number of records in the collection permitted to be affected
    """
    atMost: Int! = 1
  ): CollectionsUpdateResponse!

  """Updates zero or more records in the `Composers` collection"""
  updateComposersCollection(
    """
    Fields that are set will be updated for all records matching the `filter`
    """
    set: ComposersUpdateInput!

    """Restricts the mutation's impact to records matching the criteria"""
    filter: ComposersFilter

    """
    The maximum number of records in the collection permitted to be affected
    """
    atMost: Int! = 1
  ): ComposersUpdateResponse!

  """Updates zero or more records in the `Movement` collection"""
  updateMovementCollection(
    """
    Fields that are set will be updated for all records matching the `filter`
    """
    set: MovementUpdateInput!

    """Restricts the mutation's impact to records matching the criteria"""
    filter: MovementFilter

    """
    The maximum number of records in the collection permitted to be affected
    """
    atMost: Int! = 1
  ): MovementUpdateResponse!

  """Updates zero or more records in the `Piece` collection"""
  updatePieceCollection(
    """
    Fields that are set will be updated for all records matching the `filter`
    """
    set: PieceUpdateInput!

    """Restricts the mutation's impact to records matching the criteria"""
    filter: PieceFilter

    """
    The maximum number of records in the collection permitted to be affected
    """
    atMost: Int! = 1
  ): PieceUpdateResponse!

  """Updates zero or more records in the `PracticeSessions` collection"""
  updatePracticeSessionsCollection(
    """
    Fields that are set will be updated for all records matching the `filter`
    """
    set: PracticeSessionsUpdateInput!

    """Restricts the mutation's impact to records matching the criteria"""
    filter: PracticeSessionsFilter

    """
    The maximum number of records in the collection permitted to be affected
    """
    atMost: Int! = 1
  ): PracticeSessionsUpdateResponse!
}

interface Node {
  """Retrieves a record by `ID`"""
  nodeId: ID!
}

"""Any type not handled by the type system"""
scalar Opaque

"""
Boolean expression comparing fields on type "Opaque"
"""
input OpaqueFilter {
  eq: Opaque
  is: FilterIs
}

"""Defines a per-field sorting order"""
enum OrderByDirection {
  """Ascending order, nulls first"""
  AscNullsFirst

  """Ascending order, nulls last"""
  AscNullsLast

  """Descending order, nulls first"""
  DescNullsFirst

  """Descending order, nulls last"""
  DescNullsLast
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

"""Represents a musical piece"""
type Piece implements Node {
  """Globally Unique Record Identifier"""
  nodeId: ID!
  id: BigInt!
  workName: String!
  composerId: BigInt
  nickname: String
  userId: UUID
  format: PieceFormat
  keySignature: KeySignatureType
  catalogueType: CatalogueType
  catalogueNumber: Int
  updatedAt: Datetime
  createdAt: Datetime
  searchableText: String
  catalogueTypeNumDesc: String
  catalogueNumberSecondary: Int
  compositionYear: Int
  compositionYearDesc: String
  pieceStyle: String
  wikipediaUrl: String
  instrumentation: [String]
  compositionYearString: String
  subPieceType: String
  subPieceCount: Int
  imslpUrl: String
  imslpPieceId: BigInt
  totalPracticeTime: Int
  lastPracticed: Datetime
  composer: Composers
  movementCollection(
    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: MovementFilter

    """Sort order to apply to the collection"""
    orderBy: [MovementOrderBy!]
  ): MovementConnection
  practiceSessionsCollection(
    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: PracticeSessionsFilter

    """Sort order to apply to the collection"""
    orderBy: [PracticeSessionsOrderBy!]
  ): PracticeSessionsConnection
  collectionPieces(
    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: CollectionPiecesFilter

    """Sort order to apply to the collection"""
    orderBy: [CollectionPiecesOrderBy!]
  ): CollectionPiecesConnection

  """All collections this piece belongs to, based on shared IMSLP URL"""
  collections(
    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: CollectionsFilter

    """Sort order to apply to the collection"""
    orderBy: [CollectionsOrderBy!]
  ): CollectionsConnection
}

type PieceConnection {
  edges: [PieceEdge!]!
  pageInfo: PageInfo!
}

type PieceDeleteResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [Piece!]!
}

type PieceEdge {
  cursor: String!
  node: Piece!
}

input PieceFilter {
  id: BigIntFilter
  workName: StringFilter
  composerId: BigIntFilter
  nickname: StringFilter
  userId: UUIDFilter
  format: PieceFormatFilter
  keySignature: KeySignatureTypeFilter
  catalogueType: CatalogueTypeFilter
  catalogueNumber: IntFilter
  updatedAt: DatetimeFilter
  createdAt: DatetimeFilter
  searchableText: StringFilter
  catalogueTypeNumDesc: StringFilter
  catalogueNumberSecondary: IntFilter
  compositionYear: IntFilter
  compositionYearDesc: StringFilter
  pieceStyle: StringFilter
  wikipediaUrl: StringFilter
  instrumentation: StringListFilter
  compositionYearString: StringFilter
  subPieceType: StringFilter
  subPieceCount: IntFilter
  imslpUrl: StringFilter
  imslpPieceId: BigIntFilter
  totalPracticeTime: IntFilter
  lastPracticed: DatetimeFilter
  nodeId: IDFilter

  """
  Returns true only if all its inner filters are true, otherwise returns false
  """
  and: [PieceFilter!]

  """
  Returns true if at least one of its inner filters is true, otherwise returns false
  """
  or: [PieceFilter!]

  """Negates a filter"""
  not: PieceFilter
}

enum PieceFormat {
  bagatelle
  ballade
  canon
  caprice
  chorale
  concerto
  dance
  etude
  fantasy
  fugue
  gavotte
  gigue
  impromptu
  intermezzo
  lied
  march
  mazurka
  mass
  minuet
  nocturne
  overture
  opera
  oratorio
  pastiche
  prelude
  polonaise
  rhapsody
  requiem
  rondo
  sarabande
  scherzo
  seranade
  sonata
  string_quartet
  suite
  symphony
  tarantella
  toccata
  variations
  waltz
}

"""
Boolean expression comparing fields on type "PieceFormat"
"""
input PieceFormatFilter {
  eq: PieceFormat
  in: [PieceFormat!]
  is: FilterIs
  neq: PieceFormat
}

input PieceInsertInput {
  workName: String
  composerId: BigInt
  nickname: String
  userId: UUID
  format: PieceFormat
  keySignature: KeySignatureType
  catalogueType: CatalogueType
  catalogueNumber: Int
  updatedAt: Datetime
  createdAt: Datetime
  searchableText: String
  catalogueTypeNumDesc: String
  catalogueNumberSecondary: Int
  compositionYear: Int
  compositionYearDesc: String
  pieceStyle: String
  wikipediaUrl: String
  instrumentation: [String]
  compositionYearString: String
  subPieceType: String
  subPieceCount: Int
  imslpUrl: String
  imslpPieceId: BigInt
  totalPracticeTime: Int
  lastPracticed: Datetime
}

type PieceInsertResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [Piece!]!
}

input PieceOrderBy {
  id: OrderByDirection
  workName: OrderByDirection
  composerId: OrderByDirection
  nickname: OrderByDirection
  userId: OrderByDirection
  format: OrderByDirection
  keySignature: OrderByDirection
  catalogueType: OrderByDirection
  catalogueNumber: OrderByDirection
  updatedAt: OrderByDirection
  createdAt: OrderByDirection
  searchableText: OrderByDirection
  catalogueTypeNumDesc: OrderByDirection
  catalogueNumberSecondary: OrderByDirection
  compositionYear: OrderByDirection
  compositionYearDesc: OrderByDirection
  pieceStyle: OrderByDirection
  wikipediaUrl: OrderByDirection
  compositionYearString: OrderByDirection
  subPieceType: OrderByDirection
  subPieceCount: OrderByDirection
  imslpUrl: OrderByDirection
  imslpPieceId: OrderByDirection
  totalPracticeTime: OrderByDirection
  lastPracticed: OrderByDirection
}

input PieceUpdateInput {
  workName: String
  composerId: BigInt
  nickname: String
  userId: UUID
  format: PieceFormat
  keySignature: KeySignatureType
  catalogueType: CatalogueType
  catalogueNumber: Int
  updatedAt: Datetime
  createdAt: Datetime
  searchableText: String
  catalogueTypeNumDesc: String
  catalogueNumberSecondary: Int
  compositionYear: Int
  compositionYearDesc: String
  pieceStyle: String
  wikipediaUrl: String
  instrumentation: [String]
  compositionYearString: String
  subPieceType: String
  subPieceCount: Int
  imslpUrl: String
  imslpPieceId: BigInt
  totalPracticeTime: Int
  lastPracticed: Datetime
}

type PieceUpdateResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [Piece!]!
}

type PracticeSessions implements Node {
  """Globally Unique Record Identifier"""
  nodeId: ID!
  id: BigInt!
  startTime: Datetime!
  endTime: Datetime
  pieceId: BigInt!
  movementId: BigInt
  userId: UUID!
  durationSeconds: Int
  deletedAt: Datetime
  movement: Movement
  piece: Piece!
}

type PracticeSessionsConnection {
  edges: [PracticeSessionsEdge!]!
  pageInfo: PageInfo!
}

type PracticeSessionsDeleteResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [PracticeSessions!]!
}

type PracticeSessionsEdge {
  cursor: String!
  node: PracticeSessions!
}

input PracticeSessionsFilter {
  id: BigIntFilter
  startTime: DatetimeFilter
  endTime: DatetimeFilter
  pieceId: BigIntFilter
  movementId: BigIntFilter
  userId: UUIDFilter
  durationSeconds: IntFilter
  deletedAt: DatetimeFilter
  nodeId: IDFilter

  """
  Returns true only if all its inner filters are true, otherwise returns false
  """
  and: [PracticeSessionsFilter!]

  """
  Returns true if at least one of its inner filters is true, otherwise returns false
  """
  or: [PracticeSessionsFilter!]

  """Negates a filter"""
  not: PracticeSessionsFilter
}

input PracticeSessionsInsertInput {
  startTime: Datetime
  endTime: Datetime
  pieceId: BigInt
  movementId: BigInt
  userId: UUID
  deletedAt: Datetime
}

type PracticeSessionsInsertResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [PracticeSessions!]!
}

input PracticeSessionsOrderBy {
  id: OrderByDirection
  startTime: OrderByDirection
  endTime: OrderByDirection
  pieceId: OrderByDirection
  movementId: OrderByDirection
  userId: OrderByDirection
  durationSeconds: OrderByDirection
  deletedAt: OrderByDirection
}

input PracticeSessionsUpdateInput {
  startTime: Datetime
  endTime: Datetime
  pieceId: BigInt
  movementId: BigInt
  userId: UUID
  deletedAt: Datetime
}

type PracticeSessionsUpdateResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [PracticeSessions!]!
}

"""The root type for querying data"""
type Query {
  """A pagable collection of type `CollectionPieces`"""
  collectionPiecesCollection(
    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: CollectionPiecesFilter

    """Sort order to apply to the collection"""
    orderBy: [CollectionPiecesOrderBy!]
  ): CollectionPiecesConnection

  """A pagable collection of type `Collections`"""
  collectionsCollection(
    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: CollectionsFilter

    """Sort order to apply to the collection"""
    orderBy: [CollectionsOrderBy!]
  ): CollectionsConnection

  """A pagable collection of type `Composers`"""
  composersCollection(
    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: ComposersFilter

    """Sort order to apply to the collection"""
    orderBy: [ComposersOrderBy!]
  ): ComposersConnection

  """A pagable collection of type `Movement`"""
  movementCollection(
    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: MovementFilter

    """Sort order to apply to the collection"""
    orderBy: [MovementOrderBy!]
  ): MovementConnection

  """Retrieve a record by its `ID`"""
  node(
    """The record's `ID`"""
    nodeId: ID!
  ): Node

  """A pagable collection of type `Piece`"""
  pieceCollection(
    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: PieceFilter

    """Sort order to apply to the collection"""
    orderBy: [PieceOrderBy!]
  ): PieceConnection

  """A pagable collection of type `PracticeSessions`"""
  practiceSessionsCollection(
    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: PracticeSessionsFilter

    """Sort order to apply to the collection"""
    orderBy: [PracticeSessionsOrderBy!]
  ): PracticeSessionsConnection
  searchCollections(
    query: String!

    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: CollectionsFilter

    """Sort order to apply to the collection"""
    orderBy: [CollectionsOrderBy!]
  ): CollectionsConnection
  searchComposers(
    query: String!

    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: ComposersFilter

    """Sort order to apply to the collection"""
    orderBy: [ComposersOrderBy!]
  ): ComposersConnection
  searchPieces(
    query: String!

    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: PieceFilter

    """Sort order to apply to the collection"""
    orderBy: [PieceOrderBy!]
  ): PieceConnection
  searchUserPieces(
    query: String!

    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: PieceFilter

    """Sort order to apply to the collection"""
    orderBy: [PieceOrderBy!]
  ): PieceConnection
  showLimit: Float
}

"""
Boolean expression comparing fields on type "String"
"""
input StringFilter {
  eq: String
  gt: String
  gte: String
  ilike: String
  in: [String!]
  iregex: String
  is: FilterIs
  like: String
  lt: String
  lte: String
  neq: String
  regex: String
  startsWith: String
}

"""
Boolean expression comparing fields on type "StringList"
"""
input StringListFilter {
  containedBy: [String!]
  contains: [String!]
  eq: [String!]
  is: FilterIs
  overlaps: [String!]
}

"""A time without date information"""
scalar Time

"""
Boolean expression comparing fields on type "Time"
"""
input TimeFilter {
  eq: Time
  gt: Time
  gte: Time
  in: [Time!]
  is: FilterIs
  lt: Time
  lte: Time
  neq: Time
}

"""
Boolean expression comparing fields on type "TimeList"
"""
input TimeListFilter {
  containedBy: [Time!]
  contains: [Time!]
  eq: [Time!]
  is: FilterIs
  overlaps: [Time!]
}

"""A universally unique identifier"""
scalar UUID

"""
Boolean expression comparing fields on type "UUID"
"""
input UUIDFilter {
  eq: UUID
  in: [UUID!]
  is: FilterIs
  neq: UUID
}

"""
Boolean expression comparing fields on type "UUIDList"
"""
input UUIDListFilter {
  containedBy: [UUID!]
  contains: [UUID!]
  eq: [UUID!]
  is: FilterIs
  overlaps: [UUID!]
}