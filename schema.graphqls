"""
A directive used by the Apollo iOS client to annotate operations or fragments that should be used exclusively for generating local cache mutations instead of as standard operations.
"""
directive @apollo_client_ios_localCacheMutation on QUERY | MUTATION | SUBSCRIPTION | FRAGMENT_DEFINITION

"""
A directive used by the Apollo iOS code generation engine to generate custom import statements in operation or fragment definition files. An import statement to import a module with the name provided in the `module` argument will be added to the generated definition file.
"""
directive @import(
  """The name of the module to import."""
  module: String!
) repeatable on QUERY | MUTATION | SUBSCRIPTION | FRAGMENT_DEFINITION

"""
Directs the executor to defer this fragment when the `if` argument is true or undefined.
"""
directive @defer(
  """Deferred when true or undefined."""
  if: Boolean

  """Unique name"""
  label: String
) on FRAGMENT_SPREAD | INLINE_FRAGMENT

"""A high precision floating point value represented as a string"""
scalar BigFloat

"""
Boolean expression comparing fields on type "BigFloat"
"""
input BigFloatFilter {
  eq: BigFloat
  gt: BigFloat
  gte: BigFloat
  in: [BigFloat!]
  is: FilterIs
  lt: BigFloat
  lte: BigFloat
  neq: BigFloat
}

"""
Boolean expression comparing fields on type "BigFloatList"
"""
input BigFloatListFilter {
  containedBy: [BigFloat!]
  contains: [BigFloat!]
  eq: [BigFloat!]
  is: FilterIs
  overlaps: [BigFloat!]
}

"""An arbitrary size integer represented as a string"""
scalar BigInt

"""
Boolean expression comparing fields on type "BigInt"
"""
input BigIntFilter {
  eq: BigInt
  gt: BigInt
  gte: BigInt
  in: [BigInt!]
  is: FilterIs
  lt: BigInt
  lte: BigInt
  neq: BigInt
}

"""
Boolean expression comparing fields on type "BigIntList"
"""
input BigIntListFilter {
  containedBy: [BigInt!]
  contains: [BigInt!]
  eq: [BigInt!]
  is: FilterIs
  overlaps: [BigInt!]
}

"""
Boolean expression comparing fields on type "Boolean"
"""
input BooleanFilter {
  eq: Boolean
  is: FilterIs
}

"""
Boolean expression comparing fields on type "BooleanList"
"""
input BooleanListFilter {
  containedBy: [Boolean!]
  contains: [Boolean!]
  eq: [Boolean!]
  is: FilterIs
  overlaps: [Boolean!]
}

enum CatalogueType {
  op
  k
  twv
  bwv
  d
  hob
  rv
  s
  hwv
  h
  cnw
  woo
  do
  fp
  cd
  wab
  cff
  ms
  m
  bv
  b
  sz
  jb
  lwv
  eg
  th
  wwv
  wd
  wq
  jw
  trv
  mwv
}

"""
Boolean expression comparing fields on type "CatalogueType"
"""
input CatalogueTypeFilter {
  eq: CatalogueType
  in: [CatalogueType!]
  is: FilterIs
  neq: CatalogueType
}

type Composers implements Node {
  """Globally Unique Record Identifier"""
  nodeId: ID!
  id: BigInt!
  name: String!
  pieceCollection(
    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: PieceFilter

    """Sort order to apply to the collection"""
    orderBy: [PieceOrderBy!]
  ): PieceConnection
  imslpPieceCollection(
    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: ImslpPieceFilter

    """Sort order to apply to the collection"""
    orderBy: [ImslpPieceOrderBy!]
  ): ImslpPieceConnection
}

type ComposersConnection {
  edges: [ComposersEdge!]!
  pageInfo: PageInfo!
}

type ComposersDeleteResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [Composers!]!
}

type ComposersEdge {
  cursor: String!
  node: Composers!
}

input ComposersFilter {
  id: BigIntFilter
  name: StringFilter
  nodeId: IDFilter

  """
  Returns true only if all its inner filters are true, otherwise returns false
  """
  and: [ComposersFilter!]

  """
  Returns true if at least one of its inner filters is true, otherwise returns false
  """
  or: [ComposersFilter!]

  """Negates a filter"""
  not: ComposersFilter
}

input ComposersInsertInput {
  name: String
}

type ComposersInsertResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [Composers!]!
}

input ComposersOrderBy {
  id: OrderByDirection
  name: OrderByDirection
}

input ComposersUpdateInput {
  name: String
}

type ComposersUpdateResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [Composers!]!
}

"""
An opaque string using for tracking a position in results during pagination
"""
scalar Cursor

"""A date wihout time information"""
scalar Date

"""
Boolean expression comparing fields on type "Date"
"""
input DateFilter {
  eq: Date
  gt: Date
  gte: Date
  in: [Date!]
  is: FilterIs
  lt: Date
  lte: Date
  neq: Date
}

"""
Boolean expression comparing fields on type "DateList"
"""
input DateListFilter {
  containedBy: [Date!]
  contains: [Date!]
  eq: [Date!]
  is: FilterIs
  overlaps: [Date!]
}

"""A date and time"""
scalar Datetime

"""
Boolean expression comparing fields on type "Datetime"
"""
input DatetimeFilter {
  eq: Datetime
  gt: Datetime
  gte: Datetime
  in: [Datetime!]
  is: FilterIs
  lt: Datetime
  lte: Datetime
  neq: Datetime
}

"""
Boolean expression comparing fields on type "DatetimeList"
"""
input DatetimeListFilter {
  containedBy: [Datetime!]
  contains: [Datetime!]
  eq: [Datetime!]
  is: FilterIs
  overlaps: [Datetime!]
}

enum FilterIs {
  NULL
  NOT_NULL
}

"""
Boolean expression comparing fields on type "Float"
"""
input FloatFilter {
  eq: Float
  gt: Float
  gte: Float
  in: [Float!]
  is: FilterIs
  lt: Float
  lte: Float
  neq: Float
}

"""
Boolean expression comparing fields on type "FloatList"
"""
input FloatListFilter {
  containedBy: [Float!]
  contains: [Float!]
  eq: [Float!]
  is: FilterIs
  overlaps: [Float!]
}

"""
Boolean expression comparing fields on type "ID"
"""
input IDFilter {
  eq: ID
}

type ImslpMovement implements Node {
  """Globally Unique Record Identifier"""
  nodeId: ID!
  id: BigInt!
  pieceId: BigInt!
  name: String
  number: Int
  keySignature: KeySignatureType
  nickname: String
  downloadUrl: String
  piece: ImslpPiece!
}

type ImslpMovementConnection {
  edges: [ImslpMovementEdge!]!
  pageInfo: PageInfo!
}

type ImslpMovementDeleteResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [ImslpMovement!]!
}

type ImslpMovementEdge {
  cursor: String!
  node: ImslpMovement!
}

input ImslpMovementFilter {
  id: BigIntFilter
  pieceId: BigIntFilter
  name: StringFilter
  number: IntFilter
  keySignature: KeySignatureTypeFilter
  nickname: StringFilter
  downloadUrl: StringFilter
  nodeId: IDFilter

  """
  Returns true only if all its inner filters are true, otherwise returns false
  """
  and: [ImslpMovementFilter!]

  """
  Returns true if at least one of its inner filters is true, otherwise returns false
  """
  or: [ImslpMovementFilter!]

  """Negates a filter"""
  not: ImslpMovementFilter
}

input ImslpMovementInsertInput {
  id: BigInt
  pieceId: BigInt
  name: String
  number: Int
  keySignature: KeySignatureType
  nickname: String
  downloadUrl: String
}

type ImslpMovementInsertResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [ImslpMovement!]!
}

input ImslpMovementOrderBy {
  id: OrderByDirection
  pieceId: OrderByDirection
  name: OrderByDirection
  number: OrderByDirection
  keySignature: OrderByDirection
  nickname: OrderByDirection
  downloadUrl: OrderByDirection
}

input ImslpMovementUpdateInput {
  id: BigInt
  pieceId: BigInt
  name: String
  number: Int
  keySignature: KeySignatureType
  nickname: String
  downloadUrl: String
}

type ImslpMovementUpdateResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [ImslpMovement!]!
}

type ImslpPiece implements Node {
  """Globally Unique Record Identifier"""
  nodeId: ID!
  id: BigInt!
  workName: String!
  composerId: BigInt
  nickname: String
  format: PieceFormat
  keySignature: KeySignatureType
  catalogueType: CatalogueType
  catalogueNumber: Int
  updatedAt: Datetime
  createdAt: Datetime
  searchableText: String
  catalogueTypeNumDesc: String
  catalogueNumberSecondary: Int
  compositionYear: Int
  compositionYearDesc: String
  pieceStyle: String
  wikipediaUrl: String
  instrumentation: [String]
  compositionYearString: String
  subPieceType: String
  subPieceCount: Int
  imslpUrl: String
  collectionId: BigInt
  composer: Composers
  pieceCollection(
    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: PieceFilter

    """Sort order to apply to the collection"""
    orderBy: [PieceOrderBy!]
  ): PieceConnection
  imslpMovementCollection(
    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: ImslpMovementFilter

    """Sort order to apply to the collection"""
    orderBy: [ImslpMovementOrderBy!]
  ): ImslpMovementConnection
}

type ImslpPieceConnection {
  edges: [ImslpPieceEdge!]!
  pageInfo: PageInfo!
}

type ImslpPieceDeleteResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [ImslpPiece!]!
}

type ImslpPieceEdge {
  cursor: String!
  node: ImslpPiece!
}

input ImslpPieceFilter {
  id: BigIntFilter
  workName: StringFilter
  composerId: BigIntFilter
  nickname: StringFilter
  format: PieceFormatFilter
  keySignature: KeySignatureTypeFilter
  catalogueType: CatalogueTypeFilter
  catalogueNumber: IntFilter
  updatedAt: DatetimeFilter
  createdAt: DatetimeFilter
  searchableText: StringFilter
  catalogueTypeNumDesc: StringFilter
  catalogueNumberSecondary: IntFilter
  compositionYear: IntFilter
  compositionYearDesc: StringFilter
  pieceStyle: StringFilter
  wikipediaUrl: StringFilter
  instrumentation: StringListFilter
  compositionYearString: StringFilter
  subPieceType: StringFilter
  subPieceCount: IntFilter
  imslpUrl: StringFilter
  collectionId: BigIntFilter
  nodeId: IDFilter

  """
  Returns true only if all its inner filters are true, otherwise returns false
  """
  and: [ImslpPieceFilter!]

  """
  Returns true if at least one of its inner filters is true, otherwise returns false
  """
  or: [ImslpPieceFilter!]

  """Negates a filter"""
  not: ImslpPieceFilter
}

input ImslpPieceInsertInput {
  id: BigInt
  workName: String
  composerId: BigInt
  nickname: String
  format: PieceFormat
  keySignature: KeySignatureType
  catalogueType: CatalogueType
  catalogueNumber: Int
  updatedAt: Datetime
  createdAt: Datetime
  searchableText: String
  catalogueTypeNumDesc: String
  catalogueNumberSecondary: Int
  compositionYear: Int
  compositionYearDesc: String
  pieceStyle: String
  wikipediaUrl: String
  instrumentation: [String]
  compositionYearString: String
  subPieceType: String
  subPieceCount: Int
  imslpUrl: String
  collectionId: BigInt
}

type ImslpPieceInsertResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [ImslpPiece!]!
}

input ImslpPieceOrderBy {
  id: OrderByDirection
  workName: OrderByDirection
  composerId: OrderByDirection
  nickname: OrderByDirection
  format: OrderByDirection
  keySignature: OrderByDirection
  catalogueType: OrderByDirection
  catalogueNumber: OrderByDirection
  updatedAt: OrderByDirection
  createdAt: OrderByDirection
  searchableText: OrderByDirection
  catalogueTypeNumDesc: OrderByDirection
  catalogueNumberSecondary: OrderByDirection
  compositionYear: OrderByDirection
  compositionYearDesc: OrderByDirection
  pieceStyle: OrderByDirection
  wikipediaUrl: OrderByDirection
  compositionYearString: OrderByDirection
  subPieceType: OrderByDirection
  subPieceCount: OrderByDirection
  imslpUrl: OrderByDirection
  collectionId: OrderByDirection
}

input ImslpPieceUpdateInput {
  id: BigInt
  workName: String
  composerId: BigInt
  nickname: String
  format: PieceFormat
  keySignature: KeySignatureType
  catalogueType: CatalogueType
  catalogueNumber: Int
  updatedAt: Datetime
  createdAt: Datetime
  searchableText: String
  catalogueTypeNumDesc: String
  catalogueNumberSecondary: Int
  compositionYear: Int
  compositionYearDesc: String
  pieceStyle: String
  wikipediaUrl: String
  instrumentation: [String]
  compositionYearString: String
  subPieceType: String
  subPieceCount: Int
  imslpUrl: String
  collectionId: BigInt
}

type ImslpPieceUpdateResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [ImslpPiece!]!
}

"""
Boolean expression comparing fields on type "Int"
"""
input IntFilter {
  eq: Int
  gt: Int
  gte: Int
  in: [Int!]
  is: FilterIs
  lt: Int
  lte: Int
  neq: Int
}

"""
Boolean expression comparing fields on type "IntList"
"""
input IntListFilter {
  containedBy: [Int!]
  contains: [Int!]
  eq: [Int!]
  is: FilterIs
  overlaps: [Int!]
}

"""A Javascript Object Notation value serialized as a string"""
scalar JSON

enum KeySignatureType {
  c
  csharp
  cflat
  d
  dsharp
  dflat
  e
  esharp
  eflat
  f
  fsharp
  fflat
  g
  gsharp
  gflat
  a
  asharp
  aflat
  b
  bsharp
  bflat
  cminor
  csharpminor
  cflatminor
  dminor
  dsharpminor
  dflatminor
  eminor
  esharpminor
  eflatminor
  fminor
  fsharpminor
  fflatminor
  gminor
  gsharpminor
  gflatminor
  aminor
  asharpminor
  aflatminor
  bminor
  bsharpminor
  bflatminor
}

"""
Boolean expression comparing fields on type "KeySignatureType"
"""
input KeySignatureTypeFilter {
  eq: KeySignatureType
  in: [KeySignatureType!]
  is: FilterIs
  neq: KeySignatureType
}

type Movement implements Node {
  """Globally Unique Record Identifier"""
  nodeId: ID!
  id: BigInt!
  pieceId: BigInt!
  name: String
  number: Int
  keySignature: KeySignatureType
  nickname: String
  downloadUrl: String
  piece: Piece!
  practiceSessionsCollection(
    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: PracticeSessionsFilter

    """Sort order to apply to the collection"""
    orderBy: [PracticeSessionsOrderBy!]
  ): PracticeSessionsConnection
}

type MovementConnection {
  edges: [MovementEdge!]!
  pageInfo: PageInfo!
}

type MovementDeleteResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [Movement!]!
}

type MovementEdge {
  cursor: String!
  node: Movement!
}

input MovementFilter {
  id: BigIntFilter
  pieceId: BigIntFilter
  name: StringFilter
  number: IntFilter
  keySignature: KeySignatureTypeFilter
  nickname: StringFilter
  downloadUrl: StringFilter
  nodeId: IDFilter

  """
  Returns true only if all its inner filters are true, otherwise returns false
  """
  and: [MovementFilter!]

  """
  Returns true if at least one of its inner filters is true, otherwise returns false
  """
  or: [MovementFilter!]

  """Negates a filter"""
  not: MovementFilter
}

input MovementInsertInput {
  pieceId: BigInt
  name: String
  number: Int
  keySignature: KeySignatureType
  nickname: String
  downloadUrl: String
}

type MovementInsertResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [Movement!]!
}

input MovementOrderBy {
  id: OrderByDirection
  pieceId: OrderByDirection
  name: OrderByDirection
  number: OrderByDirection
  keySignature: OrderByDirection
  nickname: OrderByDirection
  downloadUrl: OrderByDirection
}

input MovementUpdateInput {
  pieceId: BigInt
  name: String
  number: Int
  keySignature: KeySignatureType
  nickname: String
  downloadUrl: String
}

type MovementUpdateResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [Movement!]!
}

"""The root type for creating and mutating data"""
type Mutation {
  """Deletes zero or more records from the `Composers` collection"""
  deleteFromComposersCollection(
    """Restricts the mutation's impact to records matching the criteria"""
    filter: ComposersFilter

    """
    The maximum number of records in the collection permitted to be affected
    """
    atMost: Int! = 1
  ): ComposersDeleteResponse!

  """Deletes zero or more records from the `ImslpMovement` collection"""
  deleteFromImslpMovementCollection(
    """Restricts the mutation's impact to records matching the criteria"""
    filter: ImslpMovementFilter

    """
    The maximum number of records in the collection permitted to be affected
    """
    atMost: Int! = 1
  ): ImslpMovementDeleteResponse!

  """Deletes zero or more records from the `ImslpPiece` collection"""
  deleteFromImslpPieceCollection(
    """Restricts the mutation's impact to records matching the criteria"""
    filter: ImslpPieceFilter

    """
    The maximum number of records in the collection permitted to be affected
    """
    atMost: Int! = 1
  ): ImslpPieceDeleteResponse!

  """Deletes zero or more records from the `Movement` collection"""
  deleteFromMovementCollection(
    """Restricts the mutation's impact to records matching the criteria"""
    filter: MovementFilter

    """
    The maximum number of records in the collection permitted to be affected
    """
    atMost: Int! = 1
  ): MovementDeleteResponse!

  """Deletes zero or more records from the `Piece` collection"""
  deleteFromPieceCollection(
    """Restricts the mutation's impact to records matching the criteria"""
    filter: PieceFilter

    """
    The maximum number of records in the collection permitted to be affected
    """
    atMost: Int! = 1
  ): PieceDeleteResponse!

  """Deletes zero or more records from the `PracticeSessions` collection"""
  deleteFromPracticeSessionsCollection(
    """Restricts the mutation's impact to records matching the criteria"""
    filter: PracticeSessionsFilter

    """
    The maximum number of records in the collection permitted to be affected
    """
    atMost: Int! = 1
  ): PracticeSessionsDeleteResponse!
  findOrCreateComposer(name: String!): Composers

  """Adds one or more `Composers` records to the collection"""
  insertIntoComposersCollection(objects: [ComposersInsertInput!]!): ComposersInsertResponse

  """Adds one or more `ImslpMovement` records to the collection"""
  insertIntoImslpMovementCollection(objects: [ImslpMovementInsertInput!]!): ImslpMovementInsertResponse

  """Adds one or more `ImslpPiece` records to the collection"""
  insertIntoImslpPieceCollection(objects: [ImslpPieceInsertInput!]!): ImslpPieceInsertResponse

  """Adds one or more `Movement` records to the collection"""
  insertIntoMovementCollection(objects: [MovementInsertInput!]!): MovementInsertResponse

  """Adds one or more `Piece` records to the collection"""
  insertIntoPieceCollection(objects: [PieceInsertInput!]!): PieceInsertResponse

  """Adds one or more `PracticeSessions` records to the collection"""
  insertIntoPracticeSessionsCollection(objects: [PracticeSessionsInsertInput!]!): PracticeSessionsInsertResponse
  refreshAllSearchableText: Opaque

  """Updates zero or more records in the `Composers` collection"""
  updateComposersCollection(
    """
    Fields that are set will be updated for all records matching the `filter`
    """
    set: ComposersUpdateInput!

    """Restricts the mutation's impact to records matching the criteria"""
    filter: ComposersFilter

    """
    The maximum number of records in the collection permitted to be affected
    """
    atMost: Int! = 1
  ): ComposersUpdateResponse!

  """Updates zero or more records in the `ImslpMovement` collection"""
  updateImslpMovementCollection(
    """
    Fields that are set will be updated for all records matching the `filter`
    """
    set: ImslpMovementUpdateInput!

    """Restricts the mutation's impact to records matching the criteria"""
    filter: ImslpMovementFilter

    """
    The maximum number of records in the collection permitted to be affected
    """
    atMost: Int! = 1
  ): ImslpMovementUpdateResponse!

  """Updates zero or more records in the `ImslpPiece` collection"""
  updateImslpPieceCollection(
    """
    Fields that are set will be updated for all records matching the `filter`
    """
    set: ImslpPieceUpdateInput!

    """Restricts the mutation's impact to records matching the criteria"""
    filter: ImslpPieceFilter

    """
    The maximum number of records in the collection permitted to be affected
    """
    atMost: Int! = 1
  ): ImslpPieceUpdateResponse!

  """Updates zero or more records in the `Movement` collection"""
  updateMovementCollection(
    """
    Fields that are set will be updated for all records matching the `filter`
    """
    set: MovementUpdateInput!

    """Restricts the mutation's impact to records matching the criteria"""
    filter: MovementFilter

    """
    The maximum number of records in the collection permitted to be affected
    """
    atMost: Int! = 1
  ): MovementUpdateResponse!

  """Updates zero or more records in the `Piece` collection"""
  updatePieceCollection(
    """
    Fields that are set will be updated for all records matching the `filter`
    """
    set: PieceUpdateInput!

    """Restricts the mutation's impact to records matching the criteria"""
    filter: PieceFilter

    """
    The maximum number of records in the collection permitted to be affected
    """
    atMost: Int! = 1
  ): PieceUpdateResponse!

  """Updates zero or more records in the `PracticeSessions` collection"""
  updatePracticeSessionsCollection(
    """
    Fields that are set will be updated for all records matching the `filter`
    """
    set: PracticeSessionsUpdateInput!

    """Restricts the mutation's impact to records matching the criteria"""
    filter: PracticeSessionsFilter

    """
    The maximum number of records in the collection permitted to be affected
    """
    atMost: Int! = 1
  ): PracticeSessionsUpdateResponse!
}

interface Node {
  """Retrieves a record by `ID`"""
  nodeId: ID!
}

"""Any type not handled by the type system"""
scalar Opaque

"""
Boolean expression comparing fields on type "Opaque"
"""
input OpaqueFilter {
  eq: Opaque
  is: FilterIs
}

"""Defines a per-field sorting order"""
enum OrderByDirection {
  """Ascending order, nulls first"""
  AscNullsFirst

  """Ascending order, nulls last"""
  AscNullsLast

  """Descending order, nulls first"""
  DescNullsFirst

  """Descending order, nulls last"""
  DescNullsLast
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Piece implements Node {
  """Globally Unique Record Identifier"""
  nodeId: ID!
  id: BigInt!
  workName: String!
  composerId: BigInt
  nickname: String
  userId: UUID!
  format: PieceFormat
  keySignature: KeySignatureType
  catalogueType: CatalogueType
  catalogueNumber: Int
  updatedAt: Datetime
  createdAt: Datetime
  searchableText: String
  catalogueTypeNumDesc: String
  catalogueNumberSecondary: Int
  compositionYear: Int
  compositionYearDesc: String
  pieceStyle: String
  wikipediaUrl: String
  instrumentation: [String]
  compositionYearString: String
  subPieceType: String
  subPieceCount: Int
  imslpUrl: String
  imslpPieceId: BigInt
  composer: Composers
  imslpPiece: ImslpPiece
  movementCollection(
    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: MovementFilter

    """Sort order to apply to the collection"""
    orderBy: [MovementOrderBy!]
  ): MovementConnection
  practiceSessionsCollection(
    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: PracticeSessionsFilter

    """Sort order to apply to the collection"""
    orderBy: [PracticeSessionsOrderBy!]
  ): PracticeSessionsConnection
}

type PieceConnection {
  edges: [PieceEdge!]!
  pageInfo: PageInfo!
}

type PieceDeleteResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [Piece!]!
}

type PieceEdge {
  cursor: String!
  node: Piece!
}

input PieceFilter {
  id: BigIntFilter
  workName: StringFilter
  composerId: BigIntFilter
  nickname: StringFilter
  userId: UUIDFilter
  format: PieceFormatFilter
  keySignature: KeySignatureTypeFilter
  catalogueType: CatalogueTypeFilter
  catalogueNumber: IntFilter
  updatedAt: DatetimeFilter
  createdAt: DatetimeFilter
  searchableText: StringFilter
  catalogueTypeNumDesc: StringFilter
  catalogueNumberSecondary: IntFilter
  compositionYear: IntFilter
  compositionYearDesc: StringFilter
  pieceStyle: StringFilter
  wikipediaUrl: StringFilter
  instrumentation: StringListFilter
  compositionYearString: StringFilter
  subPieceType: StringFilter
  subPieceCount: IntFilter
  imslpUrl: StringFilter
  imslpPieceId: BigIntFilter
  nodeId: IDFilter

  """
  Returns true only if all its inner filters are true, otherwise returns false
  """
  and: [PieceFilter!]

  """
  Returns true if at least one of its inner filters is true, otherwise returns false
  """
  or: [PieceFilter!]

  """Negates a filter"""
  not: PieceFilter
}

enum PieceFormat {
  bagatelle
  ballade
  canon
  caprice
  chorale
  concerto
  dance
  etude
  fantasy
  fugue
  gavotte
  gigue
  impromptu
  intermezzo
  lied
  march
  mazurka
  mass
  minuet
  nocturne
  overture
  opera
  oratorio
  pastiche
  prelude
  polonaise
  rhapsody
  requiem
  rondo
  sarabande
  scherzo
  seranade
  sonata
  string_quartet
  suite
  symphony
  tarantella
  toccata
  variations
  waltz
}

"""
Boolean expression comparing fields on type "PieceFormat"
"""
input PieceFormatFilter {
  eq: PieceFormat
  in: [PieceFormat!]
  is: FilterIs
  neq: PieceFormat
}

input PieceInsertInput {
  workName: String
  composerId: BigInt
  nickname: String
  userId: UUID
  format: PieceFormat
  keySignature: KeySignatureType
  catalogueType: CatalogueType
  catalogueNumber: Int
  updatedAt: Datetime
  createdAt: Datetime
  searchableText: String
  catalogueTypeNumDesc: String
  catalogueNumberSecondary: Int
  compositionYear: Int
  compositionYearDesc: String
  pieceStyle: String
  wikipediaUrl: String
  instrumentation: [String]
  compositionYearString: String
  subPieceType: String
  subPieceCount: Int
  imslpUrl: String
  imslpPieceId: BigInt
}

type PieceInsertResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [Piece!]!
}

input PieceOrderBy {
  id: OrderByDirection
  workName: OrderByDirection
  composerId: OrderByDirection
  nickname: OrderByDirection
  userId: OrderByDirection
  format: OrderByDirection
  keySignature: OrderByDirection
  catalogueType: OrderByDirection
  catalogueNumber: OrderByDirection
  updatedAt: OrderByDirection
  createdAt: OrderByDirection
  searchableText: OrderByDirection
  catalogueTypeNumDesc: OrderByDirection
  catalogueNumberSecondary: OrderByDirection
  compositionYear: OrderByDirection
  compositionYearDesc: OrderByDirection
  pieceStyle: OrderByDirection
  wikipediaUrl: OrderByDirection
  compositionYearString: OrderByDirection
  subPieceType: OrderByDirection
  subPieceCount: OrderByDirection
  imslpUrl: OrderByDirection
  imslpPieceId: OrderByDirection
}

input PieceUpdateInput {
  workName: String
  composerId: BigInt
  nickname: String
  userId: UUID
  format: PieceFormat
  keySignature: KeySignatureType
  catalogueType: CatalogueType
  catalogueNumber: Int
  updatedAt: Datetime
  createdAt: Datetime
  searchableText: String
  catalogueTypeNumDesc: String
  catalogueNumberSecondary: Int
  compositionYear: Int
  compositionYearDesc: String
  pieceStyle: String
  wikipediaUrl: String
  instrumentation: [String]
  compositionYearString: String
  subPieceType: String
  subPieceCount: Int
  imslpUrl: String
  imslpPieceId: BigInt
}

type PieceUpdateResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [Piece!]!
}

type PracticeSessions implements Node {
  """Globally Unique Record Identifier"""
  nodeId: ID!
  id: BigInt!
  startTime: Datetime!
  endTime: Datetime
  pieceId: BigInt!
  movementId: BigInt
  userId: UUID!
  durationSeconds: Int
  movement: Movement
  piece: Piece!
}

type PracticeSessionsConnection {
  edges: [PracticeSessionsEdge!]!
  pageInfo: PageInfo!
}

type PracticeSessionsDeleteResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [PracticeSessions!]!
}

type PracticeSessionsEdge {
  cursor: String!
  node: PracticeSessions!
}

input PracticeSessionsFilter {
  id: BigIntFilter
  startTime: DatetimeFilter
  endTime: DatetimeFilter
  pieceId: BigIntFilter
  movementId: BigIntFilter
  userId: UUIDFilter
  durationSeconds: IntFilter
  nodeId: IDFilter

  """
  Returns true only if all its inner filters are true, otherwise returns false
  """
  and: [PracticeSessionsFilter!]

  """
  Returns true if at least one of its inner filters is true, otherwise returns false
  """
  or: [PracticeSessionsFilter!]

  """Negates a filter"""
  not: PracticeSessionsFilter
}

input PracticeSessionsInsertInput {
  startTime: Datetime
  endTime: Datetime
  pieceId: BigInt
  movementId: BigInt
  userId: UUID
}

type PracticeSessionsInsertResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [PracticeSessions!]!
}

input PracticeSessionsOrderBy {
  id: OrderByDirection
  startTime: OrderByDirection
  endTime: OrderByDirection
  pieceId: OrderByDirection
  movementId: OrderByDirection
  userId: OrderByDirection
  durationSeconds: OrderByDirection
}

input PracticeSessionsUpdateInput {
  startTime: Datetime
  endTime: Datetime
  pieceId: BigInt
  movementId: BigInt
  userId: UUID
}

type PracticeSessionsUpdateResponse {
  """Count of the records impacted by the mutation"""
  affectedCount: Int!

  """Array of records impacted by the mutation"""
  records: [PracticeSessions!]!
}

"""The root type for querying data"""
type Query {
  """A pagable collection of type `Composers`"""
  composersCollection(
    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: ComposersFilter

    """Sort order to apply to the collection"""
    orderBy: [ComposersOrderBy!]
  ): ComposersConnection

  """A pagable collection of type `ImslpMovement`"""
  imslpMovementCollection(
    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: ImslpMovementFilter

    """Sort order to apply to the collection"""
    orderBy: [ImslpMovementOrderBy!]
  ): ImslpMovementConnection

  """A pagable collection of type `ImslpPiece`"""
  imslpPieceCollection(
    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: ImslpPieceFilter

    """Sort order to apply to the collection"""
    orderBy: [ImslpPieceOrderBy!]
  ): ImslpPieceConnection

  """A pagable collection of type `Movement`"""
  movementCollection(
    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: MovementFilter

    """Sort order to apply to the collection"""
    orderBy: [MovementOrderBy!]
  ): MovementConnection

  """Retrieve a record by its `ID`"""
  node(
    """The record's `ID`"""
    nodeId: ID!
  ): Node

  """A pagable collection of type `Piece`"""
  pieceCollection(
    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: PieceFilter

    """Sort order to apply to the collection"""
    orderBy: [PieceOrderBy!]
  ): PieceConnection

  """A pagable collection of type `PracticeSessions`"""
  practiceSessionsCollection(
    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: PracticeSessionsFilter

    """Sort order to apply to the collection"""
    orderBy: [PracticeSessionsOrderBy!]
  ): PracticeSessionsConnection
  searchImslpPieces(
    query: String!
    filterUserPieces: Boolean = false

    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: ImslpPieceFilter

    """Sort order to apply to the collection"""
    orderBy: [ImslpPieceOrderBy!]
  ): ImslpPieceConnection
  searchUserPieces(
    query: String!

    """Query the first `n` records in the collection"""
    first: Int

    """Query the last `n` records in the collection"""
    last: Int

    """Query values in the collection before the provided cursor"""
    before: Cursor

    """Query values in the collection after the provided cursor"""
    after: Cursor

    """
    Skip n values from the after cursor. Alternative to cursor pagination. Backward pagination not supported.
    """
    offset: Int

    """Filters to apply to the results set when querying from the collection"""
    filter: PieceFilter

    """Sort order to apply to the collection"""
    orderBy: [PieceOrderBy!]
  ): PieceConnection
  showLimit: Float
}

"""
Boolean expression comparing fields on type "String"
"""
input StringFilter {
  eq: String
  gt: String
  gte: String
  ilike: String
  in: [String!]
  iregex: String
  is: FilterIs
  like: String
  lt: String
  lte: String
  neq: String
  regex: String
  startsWith: String
}

"""
Boolean expression comparing fields on type "StringList"
"""
input StringListFilter {
  containedBy: [String!]
  contains: [String!]
  eq: [String!]
  is: FilterIs
  overlaps: [String!]
}

"""A time without date information"""
scalar Time

"""
Boolean expression comparing fields on type "Time"
"""
input TimeFilter {
  eq: Time
  gt: Time
  gte: Time
  in: [Time!]
  is: FilterIs
  lt: Time
  lte: Time
  neq: Time
}

"""
Boolean expression comparing fields on type "TimeList"
"""
input TimeListFilter {
  containedBy: [Time!]
  contains: [Time!]
  eq: [Time!]
  is: FilterIs
  overlaps: [Time!]
}

"""A universally unique identifier"""
scalar UUID

"""
Boolean expression comparing fields on type "UUID"
"""
input UUIDFilter {
  eq: UUID
  in: [UUID!]
  is: FilterIs
  neq: UUID
}

"""
Boolean expression comparing fields on type "UUIDList"
"""
input UUIDListFilter {
  containedBy: [UUID!]
  contains: [UUID!]
  eq: [UUID!]
  is: FilterIs
  overlaps: [UUID!]
}